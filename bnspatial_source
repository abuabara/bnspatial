### R wrapper to implement Bayesian Networks on raster data 
### Author: Dario Masante - dmasan@ceh.ac.uk (dario.masante at gmail.com)
### March 2016

setClasses <- function(nodes, states, classBoundaries){
	lst <- vector('list', length = length(nodes))
	names(lst) <- nodes
	for(i in 1:length(names(lst)) ){
		if(!identical(states[[i]], unique(states[[i]]))){
			print(states[[i]])
			stop('Non unique node state defined')
		}		
		lst[[i]]$States <- states[[i]]
		if(!identical(classBoundaries[[i]], unique(classBoundaries[[i]]))){
			print(classBoundaries[[i]])
			stop('Non unique "classBoundaries" defined')
		}
		if((length(classBoundaries[[i]]) - length(states[[i]])) %in% c(0, 1)){
			categorical <- ifelse(length(classBoundaries[[i]]) == length(states[[i]]), TRUE, FALSE)
		} else {
			stop('Number of classes does not match number of states. Also, for non categorical data 
				minimum and maximum boundaries must be set (-Inf and Inf allowed).')
		}
		lst[[i]]$ClassBoundaries <- classBoundaries[[i]]
		lst[[i]]$Categorical <- categorical
		if( identical(classBoundaries[[i]], sort(classBoundaries[[i]])) == FALSE & categorical == FALSE){
			print(classBoundaries[[i]])
			stop('"classBoundaries" for non categorical data must be sorted from lowest to highest')
		}
	}
	return(lst)
}

importClasses <- function(classFile){
	if(class(classFile) != 'character' | length(classFile) != 1){
		stop('Argument "classFile" must be a character vector of length one')
	}
	nodes <- vector()
	states <- list()
	classBoundaries <- list()
	classTxt <- scan(classFile, character(0), sep = "\n")
	for(i in seq(1, length(classTxt), by=3)){
		node <- classTxt[i]
		nodes <- c(nodes, node)
		state <- gsub(" ", "", unlist(strsplit(classTxt[i+1], ",")))
		states[[node]] <- state
		class <- as.numeric(gsub(" ", "", unlist(strsplit(classTxt[i+2], ","))))
		classBoundaries[[node]] <- class
	}
	setClasses(nodes=nodes, states=states, classBoundaries=classBoundaries)
}

linkNodeRaster <- function(layer, network, node, intervals, categorical=NULL, verbose=TRUE){
    network = loadNetwork(network=network)
	# Check correspondence of node and states names between lookup list and network
	checkName <- node %in% names(network$universe$levels)
	if(checkName == FALSE){
		stop('A node name provided does not match any node names from the network')		
	}
	states <- network$universe$levels[[node]]
	# Check correspondence of number of states and intervals
#	if(!is.null(intervals)) {
	if(!identical(intervals, unique(intervals))){
		stop('Non unique intervals defined')
	}
	delta <- length(intervals) - length(states)
	if(! delta %in% c(0, 1)){
		stop('Number of classes does not match number of states.')
	}
	if(!is.null(categorical)){
		if(categorical == TRUE & delta != 0) {
			stop('Number of classes does not match number of states.')
		} else if(categorical == FALSE & delta != 1) {
			stop('Number of intervals does not match number of states. For non categorical data 
				minimum and maximum boundaries must be set (-Inf and Inf allowed).')
		}
	}
	categorical <- ifelse(delta != 0, FALSE, TRUE)
	if( identical(intervals, sort(intervals)) == FALSE & categorical == FALSE){
		stop('"intervals" must be sorted from lowest to highest')
	}
	r <- raster::raster(layer)
	if(categorical == TRUE){
		v <- as.factor(raster::getValues(r))
		if(is.null(intervals)){
			intervals <- as.numeric(levels(v))
			warning('For categorical data check classes integer value and corresponding states.
				If not matching as look up list should be provided (function "setClasses")
				or modified from current list.')
		} else {
			if(identical(as.numeric(levels(v)), sort(intervals)) == FALSE){
				stop('Integer values in categorical data do not match categories provided')
			}
		}
	} 
	
	lst <- list(list(States = states, Categorical = categorical, ClassBoundaries = intervals, FilePath = layer, Raster = r))
	names(lst) <- node
	if(verbose == TRUE){
		writeLines(c(paste('\n"', node, '"', ' points to:', sep=''), 
			paste(' -> ', layer, '\n'), 
			'With states:', 
			paste(states, collapse='    '), 
			ifelse(is.null(categorical), '', ifelse(categorical == TRUE, '\nRepresented by integer values:', '\nDiscretized by intervals:')), 
			paste(intervals, collapse= ' <-> '))
		)
		writeLines('----------------------------------')
	}
	return(lst)
}

linkNodeRasterList <- function(spatialData, network, lookup, verbose=TRUE){
	if(class(lookup) == 'character' & length(lookup) == 1){
		lookup <- importClasses(lookup)
	}
	if(length(spatialData) != length(lookup)){
		stop('Spatial data files do not match the number of nodes provided in the look up list')
	}
    network = loadNetwork(network=network)
	# Check correspondence of node and states names between lookup list and network
	# then iterate through the nodes and append to summary list
	lst <- list()
	for(nm in names(lookup)){
		checkStates <- lookup[[nm]]$States %in% network$universe$levels[[nm]]
		if(any(checkStates == FALSE)){
			stop(paste("Node states provided from the look up list do not match \n node states from the network: \n \n'", 
				lookup[[nm]]$States[!checkStates], "' missing from network node", nm))
		}
		Categorical <- lookup[[nm]]$Categorical
		if(Categorical == TRUE){
			sortedClasses <- match(network$universe$levels[[nm]],lookup[[nm]]$States)
			ClassBoundaries <- lookup[[nm]]$ClassBoundaries[sortedClasses]
		} else {
			ClassBoundaries <- lookup[[nm]]$ClassBoundaries
		}
		lst[nm] <- linkNodeRaster(spatialData[ names(lookup) == nm ], network=network, node=nm, 
			intervals=ClassBoundaries, categorical=Categorical, verbose=verbose)
	}
	return(lst)
}


AOI <- function(spDataLst=NULL, msk=NULL, mskSub=NULL){
	if(is.null(msk)){
		if(is.null(spDataLst)) {
			stop('Must provide the area of interest or at least one data layer')
		}
		r <- spDataLst[[1]]$Raster
		ext <- raster::extent(r)
		cellSizeX <- raster::res(r)[1]
		cellSizeY <- raster::res(r)[2]
		for(i in 1:length(spDataLst)){
			r <- spDataLst[[i]]$Raster
			ext <- raster::union(ext, raster::extent(r) )
			cellSizeX <- ifelse(cellSizeX > raster::res(r)[1], raster::res(r)[1], cellSizeX)
			cellSizeY <- ifelse(cellSizeY > raster::res(r)[2], raster::res(r)[2], cellSizeY)
		}
		msk <- raster::raster(xmn=ext[1], xmx=ext[2], ymn=ext[3], ymx=ext[4], ext=ext, resolution=c(cellSizeX, cellSizeY), vals = 1)
	} else {
		if(class(msk) != 'RasterLayer'){
			msk <- raster::raster(msk)
		}
		id <- msk
		id[] <- 1:length(id)
		mskVals = raster::getValues(msk)
		if(!is.null(mskSub)){
			id <- raster::getValues(id)[!is.na(mskVals) & mskVals %in% mskSub]
		} else {
			id <- raster::getValues(id)[!is.na(mskVals)]
		}
		msk[]<- NA
		msk[id] <- 1
	}
	return(msk)
}


extractValuesByMask <- function(rast, msk){
	if(class(rast) != 'RasterLayer'){
		stop('"rast" argument must be an object of "RasterLayer" class.')
	}
	if(class(msk) == 'RasterLayer'){
		id <- msk
		id[] <- 1:length(id)
		id <- raster::getValues(id)[!is.na(raster::getValues(msk))]
		xy <- raster::xyFromCell(msk, id)
		cells <- raster::cellFromXY(rast, xy[, 1:2])
	} else if (class(msk) == 'matrix'){
		cells <- raster::cellFromXY(rast, msk[, 1:2])
	} else {
		stop('"msk" argument must be either an object of RasterLayer class or \n a matrix of coordinates "x" and "y"')
	}
	return( raster::getValues(rast)[cells] )
}


dataDiscretize <- function(data, classBoundaries=NULL, classStates=NULL, method="quantile"){
	if(is.null(classBoundaries)){
		if(is.null(classStates)){ 
			stop('Must provide either "classBoundaries", "classStates" or both') 
		} else {
			classBoundaries <- length(classStates)
		}
	}
	if(length(classBoundaries) == 1){
		if(!is.null(classStates) & classBoundaries != length(classStates)){
			stop('Number of bins must match the number of states')
		}
		if(classBoundaries < 2 | abs(classBoundaries - round(classBoundaries)) > 0 ){
			stop('"classBoundaries" must be an integer greater than 1, \n 
				or a vector of values to be used as class boundaries')
		}
		minimum <- min(data, na.rm=TRUE)
		maximum <- max(data, na.rm=TRUE)
		method <- match.arg(method, c("quantile", "equal"))
		if(method == "quantile"){
			classBoundaries <- quantile(data, probs=cumsum(rep(1/classBoundaries, classBoundaries-1)), na.rm=TRUE, names = FALSE)
			classBoundaries <- c(minimum, classBoundaries, maximum)
			if(any(duplicated(classBoundaries))){stop('Non unique quantile separators (a single value may cover a substantial \n  fraction of the data). Please specify a vector of class boundaries instead.')}
		} 
		if(method == "equal"){
			intervalSize <- (maximum - minimum) / classBoundaries
			classBoundaries <- minimum + cumsum(rep(intervalSize, classBoundaries-1))
			classBoundaries <- c(minimum, classBoundaries, maximum)
		}
	} else if(!is.null(classStates)){
		if(!identical(classStates, unique(classStates))){
			stop('Non unique states defined')
		}
		if((length(classBoundaries)-1) != length(classStates)){
			stop('Number of bins must match the number of states')
		}
	}
	if( identical(classBoundaries, sort(classBoundaries)) == FALSE ){
		stop('"classBoundaries" must be provided from lowest to highest')
	}
	minimum <- classBoundaries[1]
	maximum <- classBoundaries[length(classBoundaries)]
	discreteData <- findInterval(data, classBoundaries, rightmost.closed=TRUE)
	#discreteData[which(data == maximum)] <- length(classBoundaries) - 1  #Fix max value exclusion from findInterval
	discreteData[discreteData == 0 | discreteData == length(classBoundaries)] <- NA  #Remove extra classes, out of boundaries

	breaks <- classBoundaries
	minimum <- ifelse(minimum == -Inf, min(data, na.rm=TRUE), minimum)
	maximum <- ifelse(maximum == Inf, max(data, na.rm=TRUE), maximum)
	breaks[c(1, length(breaks))] <- c(minimum, maximum)
	midValues <- sapply(1:(length(breaks)-1), function(x) {(breaks[x] + breaks[x+1])/2})
	if(!is.null(classStates)){
		discreteData <- classStates[discreteData]
	} else {
		classStates <- as.character(1:length(midValues))
	}
	return(list(discreteData=discreteData, classBoundaries=classBoundaries, 
		midValues=midValues, classStates=classStates))
}

bulkDiscretize <- function(formattedLst, xy){
	extractValuesByMask <- extractValuesByMask # Trick to be used  to pass function until package is not ready
	dataDiscretize <- dataDiscretize # Trick to be used to pass function until package is not ready
	splittedData <- split(as.data.frame(xy), (seq(nrow(xy))-1) %/% (nrow(xy)/(parallel::detectCores()-1)) )
	foreach::foreach(i = 1:length(splittedData), .combine=rbind, .packages='raster') %dopar% {
		df <- lapply(names(formattedLst), function(x){
			rst <- formattedLst[[x]]$Raster
			ex <- extractValuesByMask(rast=rst, msk=as.matrix(splittedData[[i]]))
			if(formattedLst[[x]]$Categorical == TRUE){
				formattedLst[[x]]$States[match(ex, formattedLst[[x]]$ClassBoundaries)]
			} else {
				dataDiscretize(ex, formattedLst[[x]]$ClassBoundaries, formattedLst[[x]]$States)[[1]]
			}
		})
		names(df) <- names(formattedLst)
		as.matrix(as.data.frame(df))
	}
}

netQuery <- function(network, target, evidence, ...){
	evidence <- cbind(evidence, ...)
	nms <- colnames(evidence)
	fixed <- nms[duplicated(nms)]
	if(length(fixed) > 0){
		for(i in fixed){
			fix <- max(which(nms == i))
			evidence[, nms == i] <- evidence[, fix]
			evidence <- evidence[,-fix]
		}
	}
	inputNodes <- colnames(evidence)
	if(any(inputNodes %in% network$universe$nodes == FALSE)){
		print(inputNodes[!inputNodes %in% network$universe$nodes])	
		stop('One or more nodes not found in the network, please check names.')
	}
	# Create single codes to identify all existing combinations of variables state
	# Codes are preferred as character type instead of numeric, although performance may be slightly affected
	key <- as.factor(evidence)
	evidenceCoded <- matrix(as.integer(key), nrow = nrow(evidence), ncol= ncol(evidence))
	uniqueCodes <- 1:(length(levels(key))+1) # Add an index for NAs
	key <- c(levels(key), NA) # Add NA to lookup vector
	evidenceCoded[is.na(evidenceCoded)] <- length(key)
	singleCodes <- apply(evidenceCoded, 1, function(x) {paste(x, collapse="")})
	uniCodes <- unique(singleCodes)
	# Query the network only once for each identified combinations, then append results to all corresponding cases
	evidenceSingle <- as.matrix(evidence[match(uniCodes, singleCodes), ])
	probs <- apply(evidenceSingle, 1, function(x){
		if(all(is.na(x))){
			as.numeric(gRain::querygrain(network)[[target]])
		} else {
			as.numeric(gRain::querygrain(gRain::setEvidence(network, inputNodes, x)) [[target]])
		}
	})
	probs <- t(probs)[match(singleCodes, uniCodes), ]
	colnames(probs) <- network$universe$levels[[target]]
	return(probs)
}

netParallelQuery <- function(network, target, evidence, mc=(parallel::detectCores()-1), ...){
    network = loadNetwork(network=network)
	evidence <- cbind(evidence, ...)
	netQuery <- netQuery # Trick to be used  to pass function until package is not ready
	splittedData <- split(as.data.frame(evidence), (seq(nrow(evidence))-1) %/% (nrow(evidence)/mc) )
	splittedData <- lapply(1:length(splittedData), function(x){as.matrix(splittedData[[x]], ncol=ncol(evidence))})	
	foreach::foreach(i = 1:length(splittedData), .combine=rbind, .packages="gRain") %dopar% {
		netQuery(network=network, target=target, evidence=splittedData[[i]])
	}
}

mapTarget <- function(target, statesProb, what=c("class", "entropy", "probability"), msk, midvals=NULL, targetState=colnames(statesProb), spatial=TRUE, exportRaster=FALSE, path=getwd()){
    if(exportRaster == TRUE){
        rFormat <- '.tif'
    } else if (is.character(exportRaster)){
        rFormat <- exportRaster
    }
	what <- match.arg(what, c("class", "entropy", "probability", "expected", "variation"), several.ok = TRUE)
	if(spatial == TRUE){
		if(class(msk) == 'RasterLayer'){
			id <- msk
			id[] <- 1:length(id)
			id <- raster::getValues(id)[!is.na(raster::getValues(msk))]
			msk[] <- NA
		} else { 
			stop('"msk" must be an object of type "RasterLayer" as from raster::raster() function')
		}
	}
	whatList <- list()
	if('class' %in% what){
		Class <- as.factor(apply(statesProb, 1, function(x){colnames(statesProb)[which.max(x)]}) )
		if(spatial == TRUE){
			Class <- match(Class, colnames(statesProb))
			msk[id] <- Class
			Class <- msk
			keyLegend <- data.frame(colnames(statesProb), 1:length(colnames(statesProb)))
			names(keyLegend) <- c(target, 'ID')
			if(exportRaster == TRUE){
				raster::writeRaster(Class, paste(path, '/', target, '_Class', rFormat, sep=''), overwrite=TRUE, datatype='INT2S')
				write.csv(keyLegend, paste(path, target, '_ClassKey.csv', sep=''), row.names = FALSE)
			} else {
				print(keyLegend)
			}
		}
		whatList$Class <- Class
	}
 	if('expected' %in% what | 'variation' %in% what){
		if(is.null(midvals)){
			warning('Could not calculate the expected value (nor coefficient of variation) as either target node seems to be categorical or mid-values for each states of target node were not provided.')
		} else {
			Expected <- .expectedValue(statesProb, midvals)
			if('variation' %in% what){
				uncertainty <- sapply(1:length(Expected), function(x) {sqrt(sum((midvals - Expected[x])^2 * statesProb[x,]))})
				Variation <- uncertainty / Expected
				if(spatial == TRUE){ 
					msk[id] <- Variation
					Variation <- msk
					if(exportRaster == TRUE){
					    raster::writeRaster(Variation, paste(path, '/', target, '_CoeffVariation', rFormat, sep=''), overwrite=TRUE)
					}
				}
				whatList$CoeffVariation <- Variation			
			}
			if('expected' %in% what){
				if(spatial == TRUE){ 
					msk[id] <- Expected
					Expected <- msk
					if(exportRaster == TRUE){
						raster::writeRaster(Expected, paste(path, '/', target, '_ExpectedValue', rFormat, sep=''), overwrite=TRUE)
					}
				}
				whatList$ExpectedValue <- Expected
			}
		}
	}
	if('entropy' %in% what){
		Entropy <- apply(statesProb, 1, function(x){-x %*% log(x)} )
		if(spatial == TRUE){ 
			msk[id] <- Entropy
			Entropy <- msk
			if(exportRaster == TRUE){
			    raster::writeRaster(Entropy, paste(path, '/', target, '_Entropy', rFormat, sep=''), overwrite=TRUE)
			}
		}
		whatList$Entropy <- Entropy
	}	
	if('probability' %in% what){
		Probability <- lapply(targetState, function(x) {statesProb[, x]} )
		if(spatial == TRUE){
			Probability <- lapply(1:length(Probability), function(x) {msk[id] <- Probability[[x]]; return(msk)})	
		}
		names(Probability) <- targetState
		whatList$Probability <- Probability
		if(spatial == TRUE & exportRaster == TRUE){
			lapply(1:length(Probability), function(x) {raster::writeRaster(Probability[[x]], paste(path, '/', target, '_Probability_', targetState[x], rFormat, sep=''), overwrite=TRUE)})
		}
	}
	if(spatial == FALSE){
		xy <- raster::xyFromCell(msk, id)
		whatList <- cbind(id, xy, as.data.frame(whatList))
	}
	return(whatList)
}

.expectedValue <- function(statesProb, midvals) {
	return(apply(statesProb, 1, function(x){x %*% midvals}))
}


bnSpatialize <- function(network, target, spatialData, lookup, msk=NULL, what=c("class", "entropy"), 
                         midvals=NULL, targetState=NULL, spatial=TRUE, inparallel=FALSE, exportRaster=FALSE, path=NULL, ...){
#	installMissingPackages(inparallel)
	network <- loadNetwork(network=network, target=target)

	## Load table with class boundaries, if available (otherwise make a list with node name and associated vector of class boundaries)
	if(class(lookup) == 'character' & length(lookup) == 1){
	    lookup <- importClasses(classFile=lookup)
	} else if (class(lookup) == 'list' & length(lookup)[[1]] == 3 & class(lookup)[[1]] == 'list'){
	    lookup <- lookup
	} else {
		stop('Check "lookup": must be a text file or a formatted list as output from "setClasses" and "importClasses" functions')
	}

	## Load input spatial data and corresponding nodes and states into a list
	if(class(spatialData) != 'character' | length(spatialData) != length(lookup)){
		stop('Check "spatialData": must be a vector of file names of length equal to the number of corresponding nodes')
	}
	spatialDataList <- linkNodeRasterList(spatialData=spatialData, network=network, lookup=lookup)

	## Load or create mask
	msk <- AOI(spDataLst=spatialDataList, msk=msk) 
	
	## Identify, index and get coordinates of valid cells (= non NA) from area of interest/mask
	id <- msk
	id[] <- 1:length(id)
	id <- raster::getValues(id)[!is.na(raster::getValues(msk))]
	xy <- raster::xyFromCell(msk, id)

#	## Remove spatial data that was set as evidence in the ellipsis (...)
#	if(length(list(...)) > 0){
#	ls() 
#		if(ls()... %in% names(spatialDataList)){
#			spatialDataList = spatialDataList[-which(... %in% names(spatialDataList))]
#		}
#	}

	## Extract data from locations, discretize and query Bayesian network
	if(inparallel != FALSE){
	    if(inparallel == TRUE){
	        mc <- parallel::detectCores()-1
	    } else {
	        mc <- inparallel
	    }
		cl <- parallel::makePSOCKcluster(mc)
		doParallel::registerDoParallel(cl)
		tab <- bulkDiscretize(formattedLst = spatialDataList, xy)
		probs <- netParallelQuery(network=network, target=target, evidence=tab, mc=mc, ...)
		parallel::stopCluster(cl); gc()
	} else {
		tab <- matrix(nrow=nrow(xy), ncol=length(spatialDataList))
		colnames(tab) <- names(spatialDataList)
		for(nm in colnames(tab)) {
			rst <- spatialDataList[[nm]]$Raster
			ex <- extractValuesByMask(rast=rst, msk=xy)
			if(spatialDataList[[nm]]$Categorical == TRUE){
				tab[, nm] <- spatialDataList[[nm]]$States[match(ex, spatialDataList[[nm]]$ClassBoundaries)]
			} else {
				tab[, nm] <- dataDiscretize(ex, spatialDataList[[nm]]$ClassBoundaries, spatialDataList[[nm]]$States)[[1]]
			}
		}
		probs <- netQuery(network=network, target=target, evidence=tab, ...)
	}
	mapTarget(target=target, statesProb=probs, what=what, msk=msk, midvals=midvals, spatial=spatial, targetState=targetState, exportRaster=exportRaster, path=path)
}

