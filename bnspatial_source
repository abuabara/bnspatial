### R wrapper to implement Bayesian Networks on raster data 
### Author: Dario Masante 
### May 2016

setClasses <- function(nodes, states, classBoundaries, wr=NULL){
    if(length(nodes) != length(states) | length(nodes) != length(classBoundaries)){
        stop('Number of nodes not matching the list of states and/or classBoundaries provided.')
    }
	lst <- vector('list', length = length(nodes))
	names(lst) <- nodes
	for(i in 1:length(names(lst)) ){
		if(!identical(states[[i]], unique(states[[i]]))){
			print(states[[i]])
			stop('Non unique node state defined')
		}		
		lst[[i]]$States <- states[[i]]
		if(!identical(classBoundaries[[i]], unique(classBoundaries[[i]]))){
			print(classBoundaries[[i]])
			stop('Non unique "classBoundaries" defined')
		}
		if((length(classBoundaries[[i]]) - length(states[[i]])) %in% c(0, 1)){
			categorical <- ifelse(length(classBoundaries[[i]]) == length(states[[i]]), TRUE, FALSE)
		} else {
			stop('Number of classes not matching the number of states. Also, for non categorical data 
				minimum and maximum boundaries must be set (-Inf and Inf allowed).')
		}
		lst[[i]]$ClassBoundaries <- classBoundaries[[i]]
		lst[[i]]$Categorical <- categorical
		if( identical(classBoundaries[[i]], sort(classBoundaries[[i]])) == FALSE & categorical == FALSE){
			print(classBoundaries[[i]])
			stop('"classBoundaries" for non categorical data must be sorted from lowest to highest')
		}
	}
	if(!is.null(wr)){
	    .makeClassFile(wr, lst)
	}
	return(lst)
}


importClasses <- function(classFile){
	if(class(classFile) != 'character' | length(classFile) != 1){
		stop('Argument "classFile" must be a character vector of length one')
	}
	nodes <- vector()
	states <- list()
	classBoundaries <- list()
	classTxt <- scan(classFile, character(0), sep = "\n")
	for(i in seq(1, length(classTxt), by=3)){
		node <- classTxt[i]
		nodes <- c(nodes, node)
		state <- gsub(" ", "", unlist(strsplit(classTxt[i+1], ",")))
		states[[node]] <- state
		class <- as.numeric(gsub(" ", "", unlist(strsplit(classTxt[i+2], ","))))
		classBoundaries[[node]] <- class
	}
	setClasses(nodes=nodes, states=states, classBoundaries=classBoundaries)
}

.makeClassFile <- function(f, lst){
    cat("", file=f)
    for(i in 1:length(lst)){
        nm <- names(lst[i])
        cat(nm, paste(lst[[i]][[1]], collapse=","), paste(lst[[i]][[2]], collapse=","), sep="\n", file=f, append=TRUE)
    }
}

linkNodeRaster <- function(layer, network, node, intervals, categorical=NULL, verbose=TRUE){
    network = loadNetwork(network=network)
	# Check correspondence of node and states names between lookup list and network
	checkName <- node %in% names(network$universe$levels)
	if(checkName == FALSE){
		stop('A node name provided does not match any node names from the network')		
	}
	states <- network$universe$levels[[node]]
	# Check correspondence of number of states and intervals
#	if(!is.null(intervals)) {
	if(!identical(intervals, unique(intervals))){
		stop('Non unique intervals defined')
	}
	delta <- length(intervals) - length(states)
	if(! delta %in% c(0, 1)){
		stop('Number of classes does not match number of states.')
	}
	if(!is.null(categorical)){
		if(categorical == TRUE & delta != 0) {
			stop('Number of classes does not match number of states.')
		} else if(categorical == FALSE & delta != 1) {
			stop('Number of intervals does not match number of states. For non categorical data 
				minimum and maximum boundaries must be set (-Inf and Inf allowed).')
		}
	}
	categorical <- ifelse(delta != 0, FALSE, TRUE)
	if( identical(intervals, sort(intervals)) == FALSE & categorical == FALSE){
		stop('"intervals" must be sorted from lowest to highest')
	}
	if(class(layer) != 'RasterLayer'){
	    layer <- raster::raster(layer)
	}
	if(categorical == TRUE){
		v <- as.factor(raster::getValues(layer))
		if(is.null(intervals)){
			intervals <- as.numeric(levels(v))
			warning('For categorical data check classes integer value and corresponding states.
				If not matching as look up list should be provided (function "setClasses")
				or modified from current list.')
		} else {
		  ## May set as 
			if(identical(as.numeric(levels(v)), sort(intervals)) == FALSE){
				stop('Integer values in categorical data do not match categories provided')
			}
		}
	}
	
	lst <- list(list(States = states, Categorical = categorical, ClassBoundaries = intervals, Raster = layer)) #FilePath = layer@file@name, 
	names(lst) <- node
	if(verbose == TRUE){
		writeLines(c(paste('\n"', node, '"', ' points to:', sep=''), 
			paste(' -> ', layer@data@names, '\n'), 
			'With states:', 
			paste(states, collapse='    '), 
			ifelse(is.null(categorical), '', ifelse(categorical == TRUE, '\nRepresented by integer values:', '\nDiscretized by intervals:')), 
			paste(intervals, collapse= ' <-> '))
		)
		writeLines('----------------------------------')
	}
	return(lst)
}

linkNodeRasterList <- function(spatialData, network, lookup, verbose=TRUE){
	if(class(lookup) == 'character' & length(lookup) == 1){
		lookup <- importClasses(lookup)
	}
	if(length(spatialData) != length(lookup)){
		stop('Spatial data files do not match the number of nodes provided in the look up list')
	}
    network = loadNetwork(network=network)
	# Check correspondence of node and states names between lookup list and network
	# then iterate through the nodes and append to summary list
	lst <- list()
	for(nm in names(lookup)){
		checkStates <- lookup[[nm]]$States %in% network$universe$levels[[nm]]
		if(any(checkStates == FALSE)){
			stop(paste("Node states provided from the look up list do not match \n node states from the network: \n \n'", 
				lookup[[nm]]$States[!checkStates], "' missing from network node", nm))
		}
		Categorical <- lookup[[nm]]$Categorical
		if(Categorical == TRUE){
			sortedClasses <- match(network$universe$levels[[nm]],lookup[[nm]]$States)
			ClassBoundaries <- lookup[[nm]]$ClassBoundaries[sortedClasses]
		} else {
			ClassBoundaries <- lookup[[nm]]$ClassBoundaries
		}
		lst[nm] <- linkNodeRaster(spatialData[ names(lookup) == nm ][[1]], network=network, node=nm, 
			intervals=ClassBoundaries, categorical=Categorical, verbose=verbose)
	}
	return(lst)
}

AOI <- function(msk, mskSub=NULL){
    if(is.list(msk)){
        r <- msk[[1]]$Raster
        ext <- raster::extent(r)
        cellSizeX <- raster::res(r)[1]
        cellSizeY <- raster::res(r)[2]
        for(i in 1:length(msk)){
            r <- msk[[i]]$Raster
            ext <- raster::union(ext, raster::extent(r) )
            cellSizeX <- ifelse(cellSizeX > raster::res(r)[1], raster::res(r)[1], cellSizeX)
            cellSizeY <- ifelse(cellSizeY > raster::res(r)[2], raster::res(r)[2], cellSizeY)
        }
        msk <- raster::raster(xmn=ext[1], xmx=ext[2], ymn=ext[3], ymx=ext[4], ext=ext, resolution=c(cellSizeX, cellSizeY), vals = 1)
    } else {
        if(class(msk) != 'RasterLayer'){
            msk <- raster::raster(msk, RAT=FALSE)
        }
        id <- msk
        id[] <- 1:length(id)
        mskVals = raster::getValues(msk)
        if(!is.null(mskSub)){
            id <- raster::getValues(id)[!is.na(mskVals) & mskVals %in% mskSub]
        } else {
            id <- raster::getValues(id)[!is.na(mskVals)]
        }
        msk[]<- NA
        msk[id] <- 1
    }
    return(msk)
}

extractValuesByMask <- function(rast, msk){
	if(class(rast) != 'RasterLayer'){
		stop('"rast" argument must be an object of "RasterLayer" class.')
	}
	if(class(msk) == 'RasterLayer'){
		id <- msk
		id[] <- 1:length(id)
		id <- raster::getValues(id)[!is.na(raster::getValues(msk))]
		xy <- raster::xyFromCell(msk, id)
		cells <- raster::cellFromXY(rast, xy[, 1:2])
	} else if (class(msk) == 'matrix'){
		cells <- raster::cellFromXY(rast, msk[, 1:2])
	} else {
		stop('"msk" argument must be either an object of RasterLayer class or \n a matrix of coordinates "x" and "y"')
	}
	return( raster::getValues(rast)[cells] )
}

dataDiscretize <- function(data, classBoundaries=NULL, classStates=NULL, method="quantile"){
    match.arg(method, c("quantile", "equal"))
    mn <- min(data, na.rm=TRUE)
    mx <- max(data, na.rm=TRUE)

    classBoundaries <- .makeClassBoundaries(data=data, classBoundaries=classBoundaries, classStates=classStates, method=method, mn=mn, mx=mx)
	
    minimum <- classBoundaries[1]
	maximum <- classBoundaries[length(classBoundaries)]
	discreteData <- findInterval(data, classBoundaries, rightmost.closed=TRUE)
	#discreteData[which(data == maximum)] <- length(classBoundaries) - 1  #Fix max value exclusion from findInterval
	discreteData[discreteData == 0 | discreteData == length(classBoundaries)] <- NA  #Remove extra classes, out of boundaries

	breaks <- classBoundaries
	minimum <- ifelse(minimum == -Inf, mn, minimum)
	maximum <- ifelse(maximum == Inf, mx, maximum)
	breaks[c(1, length(breaks))] <- c(minimum, maximum)
	midValues <- sapply(1:(length(breaks)-1), function(x) {(breaks[x] + breaks[x+1])/2})
	if(!is.null(classStates)){
		discreteData <- classStates[discreteData]
	} else {
		classStates <- as.character(1:length(midValues))
	}
	return(list(discreteData=discreteData, classBoundaries=classBoundaries, 
		midValues=midValues, classStates=classStates))
}

.makeClassBoundaries <- function(data, classBoundaries, classStates, method, mn, mx){
    if(is.null(classBoundaries)){
        if(is.null(classStates)){ 
            stop('Must provide either "classBoundaries", "classStates" or both') 
        } else if(length(classStates) < 2){
            stop('"classStates" must be a vector of length greater than 1')
        } else {
            classBoundaries <- length(classStates)
        }
    }
    if(length(classBoundaries) == 1){
        if(!is.null(classStates) & classBoundaries != length(classStates)){
            stop('Number of bins must match the number of states')
        }
        if(classBoundaries < 2 | abs(classBoundaries - round(classBoundaries)) > 0 ){
            stop('"classBoundaries" must be an integer greater than 1, 
                 or a vector of values to be used as class boundaries')
        }
        if(method == "quantile"){
            classBoundaries <- quantile(data, probs=cumsum(rep(1/classBoundaries, classBoundaries-1)), na.rm=TRUE, names = FALSE)
            classBoundaries <- c(mn, classBoundaries, mx)
            if(any(duplicated(classBoundaries))){
                stop('Non unique quantile separators (a single value may cover a substantial fraction of the data). Please specify a vector of class boundaries instead.')
            }
        } 
        if(method == "equal"){
            intervalSize <- (mx - mn) / classBoundaries
            classBoundaries <- mn + cumsum(rep(intervalSize, classBoundaries-1))
            classBoundaries <- c(mn, classBoundaries, mx)
        }
        } else if(!is.null(classStates)){
            if(!identical(classStates, unique(classStates))){
                stop('Non unique states defined')
            }
            if((length(classBoundaries)-1) != length(classStates)){
                stop('Number of bins must match the number of states')
            }
        }
    ## perform some more checks  
    if(!identical(classBoundaries, sort(classBoundaries))){
        stop('"classBoundaries" must be provided from lowest to highest')
    }
    if(!identical(classBoundaries, unique(classBoundaries))){
        warning('Non unique values provided in "classBoundaries"')
    }
    cb <- classBoundaries[-c(1, length(classBoundaries))]
    if(any(cb < mn | cb > mx)){
        cb <- cb[which(cb < mn | cb > mx)]
        warning('One or more classes fall entirely out of data range. Check "classBoundaries".')
    }
    if(length(cb) == 0 & any(classBoundaries[2] < mn | classBoundaries[1] > mx)){
        stop('All classes empty. Check "classBoundaries".')
    }
    return(classBoundaries)
}

bulkDiscretize <- function(formattedLst, xy, inparallel=FALSE){
    mc <- .inParallel(inparallel)
	splittedData <- split(as.data.frame(xy), (seq(nrow(xy))-1) %/% (nrow(xy) / mc ) )
	foreach::foreach(i = 1:length(splittedData), .combine=rbind, .packages='raster') %dopar% {
		df <- lapply(names(formattedLst), function(x){
			rst <- formattedLst[[x]]$Raster
			ex <- extractValuesByMask(rast=rst, msk=as.matrix(splittedData[[i]]))
			if(formattedLst[[x]]$Categorical == TRUE){
				formattedLst[[x]]$States[match(ex, formattedLst[[x]]$ClassBoundaries)]
			} else {
				dataDiscretize(ex, formattedLst[[x]]$ClassBoundaries, formattedLst[[x]]$States)[[1]]
			}
		})
		names(df) <- names(formattedLst)
		as.matrix(as.data.frame(df))
	}
}

.inParallel <- function(inparallel){
    if(is.logical(inparallel)){
        n <- ifelse(inparallel == TRUE, parallel::detectCores()-1, 1)
    } else {
        #n <- min(parallel::detectCores(), inparallel)
        n <- inparallel
    }
    return(n)
}

netQuery <- function(network, target, evidence, ...){
	evidence <- cbind(evidence, ...)
	nms <- colnames(evidence)
	fixed <- nms[duplicated(nms)]
	if(length(fixed) > 0){
		for(i in fixed){
			fix <- max(which(nms == i))
			evidence[, nms == i] <- evidence[, fix]
			evidence <- evidence[,-fix]
		}
	}
	inputNodes <- colnames(evidence)
	if(any(inputNodes %in% network$universe$nodes == FALSE)){
		print(inputNodes[!inputNodes %in% network$universe$nodes])	
		stop('One or more nodes not found in the network, please check names.')
	}
	# Create single codes to identify all existing combinations of variables state
	# Codes are preferred as character type instead of numeric, although performance may be slightly affected
	key <- as.factor(evidence)
	evidenceCoded <- matrix(as.integer(key), nrow = nrow(evidence), ncol= ncol(evidence))
	uniqueCodes <- 1:(length(levels(key))+1) # Add an index for NAs
	key <- c(levels(key), NA) # Add NA to lookup vector
	evidenceCoded[is.na(evidenceCoded)] <- length(key)
	singleCodes <- apply(evidenceCoded, 1, function(x) {paste(x, collapse="")})
	uniCodes <- unique(singleCodes)
	# Query the network only once for each identified combinations, then append results to all corresponding cases
	evidenceSingle <- as.matrix(evidence[match(uniCodes, singleCodes), ])
	probs <- apply(evidenceSingle, 1, function(x){
		if(all(is.na(x))){
			as.numeric(gRain::querygrain(network)[[target]])
		} else {
			as.numeric(gRain::querygrain(gRain::setEvidence(network, inputNodes, x)) [[target]])
		}
	})
	probs <- t(probs)[match(singleCodes, uniCodes), ]
	colnames(probs) <- network$universe$levels[[target]]
	return(probs)
}

netParallelQuery <- function(network, target, evidence, mc=(parallel::detectCores()-1), ...){
    network <- loadNetwork(network=network)
	evidence <- cbind(evidence, ...)
	splittedData <- split(as.data.frame(evidence), (seq(nrow(evidence))-1) %/% (nrow(evidence)/mc) )
	splittedData <- lapply(1:length(splittedData), function(x){as.matrix(splittedData[[x]], ncol=ncol(evidence))})	
	foreach::foreach(i = 1:length(splittedData), .combine=rbind, .packages="gRain") %dopar% {
		netQuery(network=network, target=target, evidence=splittedData[[i]])
	}
}

mapTarget <- function(target, statesProb, what=c("class", "entropy", "probability"), msk, midvals=NULL, targetState=colnames(statesProb), spatial=TRUE, exportRaster=FALSE, path=getwd()){
    if(exportRaster == TRUE){
        rFormat <- '.tif'
    } else if (is.character(exportRaster)){
        #match.arg(exportRaster, c('.asc','.sdat','.rst','.nc','.tif','.envi','.bil'))
        rFormat <- exportRaster
    }
	what <- match.arg(what, c("class", "entropy", "probability", "expected", "variation"), several.ok = TRUE)
	if(spatial == TRUE){
		if(class(msk) == 'RasterLayer'){
			id <- msk
			id[] <- 1:length(id)
			id <- raster::getValues(id)[!is.na(raster::getValues(msk))]
			msk[] <- NA
		} else { 
			stop('"msk" must be an object of class "RasterLayer"')
		}
	}
	whatList <- list()
	if('class' %in% what){
		Class <- as.factor(apply(statesProb, 1, function(x){colnames(statesProb)[which.max(x)]}) )
		if(spatial == TRUE){
			Class <- match(Class, colnames(statesProb))
			msk[id] <- Class
			Class <- msk
			keyLegend <- data.frame(colnames(statesProb), 1:length(colnames(statesProb)))
			names(keyLegend) <- c(target, 'ID')
			if(exportRaster == TRUE){
				raster::writeRaster(Class, paste(path, '/', target, '_Class', rFormat, sep=''), overwrite=TRUE, datatype='INT2S')
				write.csv(keyLegend, paste(path, target, '_ClassKey.csv', sep=''), row.names = FALSE)
			} else {
				print(keyLegend)
			}
		}
		whatList$Class <- Class
	}
 	if('expected' %in% what | 'variation' %in% what){
		if(is.null(midvals)){
			warning('Could not calculate the expected value (nor coefficient of variation) as either target node seems to be categorical or mid-values for each states of target node were not provided.')
		} else {
			Expected <- .expectedValue(statesProb, midvals)
			if('variation' %in% what){
				uncertainty <- sapply(1:length(Expected), function(x) {sqrt(sum((midvals - Expected[x])^2 * statesProb[x,]))})
				Variation <- uncertainty / Expected
				if(spatial == TRUE){ 
					msk[id] <- Variation
					Variation <- msk
					if(exportRaster == TRUE){
					    raster::writeRaster(Variation, paste(path, '/', target, '_CoeffVariation', rFormat, sep=''), datatype='FLT4S', overwrite=TRUE)
					}
				}
				whatList$CoeffVariation <- Variation			
			}
			if('expected' %in% what){
				if(spatial == TRUE){ 
					msk[id] <- Expected
					Expected <- msk
					if(exportRaster == TRUE){
						raster::writeRaster(Expected, paste(path, '/', target, '_ExpectedValue', rFormat, sep=''), datatype='FLT4S', overwrite=TRUE)
					}
				}
				whatList$ExpectedValue <- Expected
			}
		}
	}
	if('entropy' %in% what){
		Entropy <- apply(statesProb, 1, function(x){-x %*% log(x)} )
		if(spatial == TRUE){ 
			msk[id] <- Entropy
			Entropy <- msk
			if(exportRaster == TRUE){
			    raster::writeRaster(Entropy, paste(path, '/', target, '_Entropy', rFormat, sep=''), datatype='FLT4S', overwrite=TRUE)
			}
		}
		whatList$Entropy <- Entropy
	}	
	if('probability' %in% what){
		Probability <- lapply(targetState, function(x) {statesProb[, x]} )
		if(spatial == TRUE){
			Probability <- lapply(1:length(Probability), function(x) {msk[id] <- Probability[[x]]; return(msk)})	
		}
		names(Probability) <- targetState
		whatList$Probability <- Probability
		if(spatial == TRUE & exportRaster == TRUE){
			lapply(1:length(Probability), function(x) {
			  raster::writeRaster(Probability[[x]], paste(path, '/', target, '_Probability_', targetState[x], rFormat, sep=''), datatype='FLT4S', overwrite=TRUE)
			})
		}
	}
	if(spatial == FALSE){
		xy <- raster::xyFromCell(msk, id)
		whatList <- cbind(id, xy, as.data.frame(whatList))
	}
	return(whatList)
}

.expectedValue <- function(statesProb, midvals) {
	return(apply(statesProb, 1, function(x){x %*% midvals}))
}


bnSpatialize <- function(network, target, spatialData, lookup, msk=NULL, what=c("class", "entropy"), 
                         midvals=NULL, targetState=NULL, spatial=TRUE, inparallel=FALSE, exportRaster=FALSE, path=NULL, ...){
#	installMissingPackages(inparallel)
	network <- loadNetwork(network, target)

	## Load table with class boundaries, if available (otherwise make a list with node name and associated vector of class boundaries)
	if(class(lookup) == 'character' & length(lookup) == 1){
	    lookup <- importClasses(classFile=lookup)
	} else if (class(lookup) == 'list' & length(lookup)[[1]] == 3 & class(lookup)[[1]] == 'list'){
	    lookup <- lookup
	} else {
		stop('Check "lookup": must be a text file or a formatted list as output from "setClasses" and "importClasses" functions')
	}

	## Load input spatial data and corresponding nodes and states into a list
	if(class(spatialData) != 'character' | length(spatialData) != length(lookup)){
		stop('Check "spatialData": must be a vector of file names of length equal to the number of corresponding nodes')
	}
	spatialDataList <- linkNodeRasterList(spatialData=spatialData, network=network, lookup=lookup)

	## Load or create mask
	if(is.null(msk)){
	    msk <- AOI(spatialDataList)
	} else {
	    msk <- AOI(msk)
	}
	
	## Identify, index and get coordinates of valid cells (= non NA) from area of interest/mask
	id <- msk
	id[] <- 1:length(id)
	id <- raster::getValues(id)[!is.na(raster::getValues(msk))]
	xy <- raster::xyFromCell(msk, id)

	## Extract data from locations, discretize and query Bayesian network
	if(inparallel != FALSE){
	    mc <- .inParallel(inparallel)
		cl <- parallel::makePSOCKcluster(mc)
		doParallel::registerDoParallel(cl)
		tab <- bulkDiscretize(formattedLst = spatialDataList, xy, inparallel=mc)
		probs <- netParallelQuery(network=network, target=target, evidence=tab, mc=mc, ...)
		parallel::stopCluster(cl); gc()
	} else {
		tab <- matrix(nrow=nrow(xy), ncol=length(spatialDataList))
		colnames(tab) <- names(spatialDataList)
		for(nm in colnames(tab)) {
			rst <- spatialDataList[[nm]]$Raster
			ex <- extractValuesByMask(rast=rst, msk=xy)
			if(spatialDataList[[nm]]$Categorical == TRUE){
				tab[, nm] <- spatialDataList[[nm]]$States[match(ex, spatialDataList[[nm]]$ClassBoundaries)]
			} else {
				tab[, nm] <- dataDiscretize(ex, spatialDataList[[nm]]$ClassBoundaries, spatialDataList[[nm]]$States)[[1]]
			}
		}
		probs <- netQuery(network=network, target=target, evidence=tab, ...)
	}
	mapTarget(target=target, statesProb=probs, what=what, msk=msk, midvals=midvals, spatial=spatial, targetState=targetState, exportRaster=exportRaster, path=path)
}

